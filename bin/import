#!/usr/bin/env node

'use strict';

const fetch = require('node-fetch');
const fs = require('fs');
const mkdirp = require('mkdirp');
const models = require('../models');
const path = require('path');
const readline = require('readline');
const XLSX = require('xlsx');
const { URLSearchParams } = require('url');
const _ = require('lodash');

if (process.argv.length < 3) {
  console.log('Usage: bin/import path/to/file.xlsx');
  process.exit(1);
}

parseWorkbook();

function downloadWorkbook(url) {
  return new Promise(function(resolve, reject) {
    mkdirp.sync(path.resolve(__dirname, '../tmp'));
    const filename = path.resolve(__dirname, '../tmp/file.xlsx');
    const file = fs.createWriteStream(filename);
    fetch(url).then(function(response) {
      response.body.on('end', function() {
        resolve(filename);
      });
      response.body.pipe(file)
    });
  });
}

function readInput(rl, prompt) {
  return new Promise(function(resolve, reject) {
    rl.question(prompt, function(answer) {
      resolve(answer)
    });
  });
}

async function parseWorkbook() {
  //// download file, if url
  let filename = process.argv[2];
  if (filename.startsWith('http')) {
    console.log('Downloading workbook...');
    filename = await downloadWorkbook(filename);
  }

  //// read Excel workbook
  console.log('Parsing workbook...');
  const workbook = XLSX.readFile(filename);

  //// set up console input/output
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  let server = await readInput(rl, 'Select a server to import into [http://localhost:3000]: ');
  if (server == '') {
    server = 'http://localhost:3000';
  }
  let email = await readInput(rl, 'Email: ');
  let password = await readInput(rl, 'Password: ');

  //// enumerate all the sheets in the workbook
  let i = 1;
  for (let sheetName of workbook.SheetNames) {
    console.log(`${i}. ${sheetName}`);
    i += 1;
  }

  //// prompt user for sheet selection
  let sheet = await readInput(rl, 'Select a sheet to import [1]: ');
  if (sheet == '') {
    sheet = '1';
  }
  i = parseInt(sheet) - 1;
  importRows(server, email, password, workbook.Sheets[workbook.SheetNames[i]])
    .then(function() {
      console.log('Done!');
    })
    .catch(function(error) {
      console.log(error);
    })
    .finally(function() {
      //// clean up and exit
      rl.close();
      process.exit();
    });
}

function login(server, email, password) {
  const params = new URLSearchParams();
  params.append('email', email);
  params.append('password', password);
  return fetch(`${server}/login`, {
    method: 'post',
    body: params,
    redirect: 'manual'
  }).then(function(res) {
    let cookies = res.headers.raw()['set-cookie'];
    cookies = cookies.map((entry) => {
      const parts = entry.split(';');
      const cookiePart = parts[0];
      return cookiePart;
    }).join(';');
    return cookies;
  });
}

function post(server, cookies, path, data) {
  return fetch(`${server}${path}`, {
    method: 'post',
    body: JSON.stringify(data),
    headers: {
      'Content-Type': 'application/json',
      'Cookie': cookies
    }
  }).then(function(res) {
    if (!res.ok) {
      return res.text().then(function(text) {
        throw text;
      });
    } else {
      return res.json();
    }
  });
}

async function importRows(server, email, password, sheet) {
  //// log in to server
  let cookie = await login(server, email, password);
  //// the priority strings used in this spreadsheet, mapped in order
  //// from high to low, intended to map to the corresponding SALT priorities
  const PRIORITIES = ['Red', 'Yellow', 'Green', 'Gray', 'Deceased'];
  const rows = XLSX.utils.sheet_to_json(sheet, {header: 1});
  //// remove header rows
  rows.splice(0, 3);
  //// process each row...
  let i = 0;
  for (let row of rows) {
    //// get unique PIN for the patient
    let pin = row[0];
    if (!pin) {
      //// empty row marks end of input...
      break;
    }
    pin = models.Patient.generatePIN(pin);
    console.log(`[${i}] PIN: ${pin}`);
    //// collect initial vitals and status
    let lastName = (row[1] || '').trim();
    let firstName = (row[2] || '').trim();
    let age = row[3];
    let respiratoryRate = row[4];
    let pulse = row[5];
    let capillaryRefill = row[6];
    let bloodPressure = (row[7] || '').trim();
    let text = (row[8] || '').trim();
    let priority = PRIORITIES.indexOf((row[9] || '').trim());
    if (priority < 0 || priority >= PRIORITIES.length) {
      console.error(`Unrecognized priority: ${row[9]}`);
      exit(1);
    }
    let location = (row[10] || '').trim();
    let portraitUrl = (row[19] || '').trim();
    let portraitUrlPath = path.resolve(__dirname, '../public/uploads', portraitUrl)
    if (fs.existsSync(portraitUrlPath)) {
      mkdirp.sync(path.resolve(__dirname, '../tmp/uploads/observations/portrait'));
      fs.copyFileSync(portraitUrlPath, path.resolve(__dirname, '../tmp/uploads', portraitUrl));
    } else {
      portraitUrl = null;
    }
    let lat = (`${row[20] || ''}` || '').trim();
    let lng = (`${row[21] || ''}` || '').trim();
    //// TODO handle back-dating timestamp row[11] for demo purposes
    //// create initial patient/observation record
    let observation = await post(server, cookie, '/api/observations', {
      pin,
      lastName,
      firstName,
      age,
      respiratoryRate,
      pulse,
      capillaryRefill,
      bloodPressure,
      text,
      priority,
      location,
      lat,
      lng,
      portraitUrl
    });

    //// create second observation
    text = (row[12] || '').trim();
    priority = PRIORITIES.indexOf((row[13] || '').trim());
    location = (row[14] || '').trim();
    //// TODO handle back-dating timestamp row[15] for demo purposes
    let payload = {};
    if (text != '') {
      payload['text'] = text;
    }
    if (priority >= 0 && priority < PRIORITIES.length) {
      payload['priority'] = priority;
    }
    if (location != '' && location != 'Same') {
      payload['location'] = location;
    }
    if (!_.isEmpty(payload)) {
      payload['pin'] = pin;
      observation = await post(server, cookie, '/api/observations', payload);
    }
    i += 1;
  }
}
